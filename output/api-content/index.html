{"posts":[{"title":"P1895 数字序列 Solution","content":"我们可以把 “112123123412345123456……n112123123412345123456……n112123123412345123456……n” 分解成： 111 121212 123123123 123412341234 123451234512345 123456123456123456 .................. 123123123 ……………… nnn 那我们首先想到的是对每一个子序列的长度进行求解： 经过实践，我们可以发现一个规律： 当这个数是 nnn 位数时：leni=leni−1+nlen_i=len_{i-1}+nleni​=leni−1​+n 这个预处理是非常简单的，代码如下： 总体思路： 判断 nnn 处于哪一个子序列中（假设在第 iii 个子序列中）。 计算 nnn 是第 iii 个子序列的第几个字符。 每次给第 iii 个子序列添加一个数（原来为空），如果该子序列的长度已经达到了 nnn ，那么就输出该子序列的第 nnn 个字符。 完整代码： 说明：本人乃2016级小学生，思路比较简单，题解如有写的不好的地方请指正。写这篇题解是为了巩固一下，因为查错查了很久。 ","link":"https://xinttao.github.io/post/luoguP1895-number-sequence-Solution/"},{"title":"P3982  龙盘雪峰信息解析器 Solution","content":"首先，我们来分析一下每一个规则： 若【前三个字符】为 101101101 时表示需要转换为字母 A−ZA-ZA−Z ，字母 AAA 代码为 101000001010000010100000 ，字母 CCC 为 101000101010001010100010 ， 262626 个大写字母以字母表顺序按照这种规律顺序排列，分别对应一个二进制代码。 对于第 111 个规则，该单元是用第 444 位到第 888 位来表示这一个字母的二进制代码（ 00000−1101000000-1101000000−11010 分别代表 A−ZA-ZA−Z）。那么，重点来了： 如果第 444 位到第 888 位所表示的 222 进制数比 110101101011010 大，那么就是“Error”。 若【前三个字符】为 111111111 ，则该单元翻译为空格。 第 222 个规则，非常好判断。 若【第一个字符】为 000 ，则该单元表示一个数，待定与 下一个单元所表示的数做加法。加法过程中，这两个单元应转换为十进制，然后除以 222 取整再相加，加法结束后，这两个单元做加法得到的结果即为这两个单元的翻译结果（翻译结果用十进制表示，这两个单元就都翻译完毕了）。 对于第 333 个规则，如果出现加法单元，那么它必定是成对出现的，如果没有满足条件，那么就是“Error”。 因为我们可能在判断某一个单元的途中发现“Error”，所以我们需要一个字符串 $ ans $ 来储存答案。 General{\\color{SkyBlue}General}General Ideas{\\color{SkyBlue}Ideas}Ideas 重点是判断“Error”的情况。 那么如何判断是否“Error”呢？如下： Error-1. 某个单元不完整。 Error-2. 代码中出现别的奇奇怪怪的字符。 Error-3. 加法单元没有成对出现。 Error-4. 字母单元所表示的字符不在 A−ZA-ZA−Z 范围内。 Code{\\color{SkyBlue}Code}Code 说明：By Xin。本人乃2016级小学生，思路比较简单，题解如有写的不好的地方请指正。 ","link":"https://xinttao.github.io/post/luoguP3982-Longpan-Xuefeng-information-parser-Solution/"},{"title":"P1871 对撞机 Solution","content":"可能更好的食用体验 题目传送门 样例解释{\\color{RoyalBlue}\\colorbox {white}{样例解释}}样例解释​ 题目已经讲得很清楚了，就是每次打开的对撞机编号一定要与之前所有打开的对撞机编号互质。如第 222 个询问要打开 101010 号对撞机，而 101010 与前面的 666 不互质，故输出 “ Conflict with 666 ” 。其他的也就不用我多说了。还有一点要注意，在第 999 个询问中 666 既与 333 冲突也与 101010 冲突，不要被样例忽悠了，输出任意一个都是对的，我的程序输出就是“ Conflict with 101010 ” 。 主要思路{\\color{RoyalBlue}\\colorbox {white}{主要思路}}主要思路​ 既然要使每次打开的对撞机编号与之前所有都互质，也就是要使每次打开的对撞机的编号的质因数中不包含之前出现过质因数。我们可以每次将编号进行分解质因数，如果其中的质因数在之前被标记过，则不能开启。如果其中的质因数在之前都没出现过，就开启这个对撞机，并记录这些质因数。开启的代码如下： 关闭也很简单，分解其质因数并删除标记即可。 然后就在主程序中判断函数的返回值并输出即可。 完整代码{\\color{RoyalBlue}\\colorbox {white}{完整代码}}完整代码​ xt__温馨提示： ${\\color{brown}\\colorbox{White}{题解千万条，理解第一条。直接粘题解，棕名两行泪。}} $ ","link":"https://xinttao.github.io/post/luoguP1871-collider-Solution/"},{"title":"codeforces955A Feed the cat Solution","content":"可能更好的食用体验 题目传送门 这题很简单，直接上代码 唯一要注意的是翻译中的一句话： “因此从 20:00 开始，面包有 202020 的特别折扣” 其中有 202020 的特别折扣指价格降低202020%，即将价格乘0.80.80.8 xt__温馨提示： ${\\color{brown}\\colorbox{White}{题解千万条，理解第一条。直接粘题解，棕名两行泪。}} $ ","link":"https://xinttao.github.io/post/codeforces955A-Feed-the-cat-Solution/"},{"title":"€＄₱-J2021游记-by.Tao","content":"一名小学六年级蒟蒻第一次参加€＄₱，好紧张~ 初赛 初赛不得不说真的很恶心（至少对我来说）。值得庆幸的是，我还是以压线的分数顺利（bushi）进入了复赛（吐槽：GD出分真是太慢了╮(╯▽╰)╭）。这里真的要感谢洛谷有题给了我们练习平台，真的很有用！！！同时也感谢我的教练和同学给予的支持与鼓励。 无论如何，只要过了初赛，复赛不用顾虑那么多了。 复赛 墙裂推荐《深入浅出程序设计竞赛》！！真的写的很好、很详尽！！ 我本来就对复赛没报太大的信心，赛前估分 &lt;200&lt;200&lt;200，毕竟我也才六年级嘛。不过今年的题确实比以往要简单一点，还没考动规，每道题都能或多或少水一些分。下面我会分享一下我做每道题时的思路、想法、策略、代码等（不过基本都是错误的，就当反面教材来看吧QwQ）。 声明：以下标题后的“自测”都是指洛谷估分。 T1. 分糖果（洛谷P7909）$\\ \\ $自测100分 这是我唯一一道做对的题了。我也看了一下其他一些人的AC代码，发现我的代码好像也是最简单的了。下面我也简单的分析一些我这道题的思路： 答案最大只能是 n−1n-1n−1，这是毋庸置疑的。 我们可以先找到小于 lll 的最大的 nnn 的倍数，即⌊l÷n⌋×n\\left\\lfloor l\\div n \\right\\rfloor\\times n⌊l÷n⌋×n。这时答案最大只能是r−⌊l÷n⌋×nr-\\left\\lfloor l\\div n \\right\\rfloor\\times nr−⌊l÷n⌋×n，超过了就拿不了了。 答案就是 n−1n-1n−1 与 r−⌊l÷n⌋×nr-\\left\\lfloor l\\div n \\right\\rfloor\\times nr−⌊l÷n⌋×n 中的最小值。 代码非常之简单，没有奇奇怪怪的条件判断或循环什么的。 T2.插入排序（洛谷P7910）$\\ \\ $自测52分 比赛时实在想不出什么好了思路了哇哇哇。。。只好暴力水分了。暴力就没啥好说的了，自己看代码就能看出来。 我在这题尝试了很多其他方法，耗了不少时间，虽然不会超时，但无一例外的都是答案错误。最后还是选择了暴力。 赛时估分303030以下，自测525252分也是令我很意外了，希望€€£的数据能更水点吧（逃）。 T3.网络连接(洛谷P7911)$\\ \\ $自测65分 这题其实就是大模拟啊！但是由于我在第二题花了太多时间，以至于我第三题没有太多时间写，现在想来还有些不甘。我在这题的策略就是不考虑不符合规范的情况，这样可以省不少代码，还能水到不少分数。我的代码如下： 赛时估分其实也不高，民间数据总能带给人惊喜，不过你谷民间数据一直都不咋靠谱（逃）。 T4.网络连接(洛谷P7912)$\\ \\ $自测10分 这道题请求大佬的帮助。我先来分享一下我的思路： 首先是读入。读入我使用了一个队列数组存储每一个“块”，只要每次读入到的水果与上一个不同，就存储到下一个队列中。 读入代码如下： 接着，我循环枚举每一个队列，只要队列不空就输出队列的队头的位置，并弹出队头。直到所有队列都为空为止。 如何解决两个“块”合并的问题？可以使用一个变量记录上一个不空的队列编号，只要当前队列的水果与上一个相同，就将当前队列连接到上一个队列的后面。即：每次将当前队列的队头弹出并入到上一个队列中。 主要思路到这里就介绍完了。下面还是附上完整代码： 测评结果如下图（用小号测的，莫见怪）： TLE还能理解，为什么会WA呢？请求大佬指出代码/思路的错误。 $upd\\ on\\ 2021.10.27\\ $：现已解决，感谢大佬 （还是我太蒻了啊） 洛谷估分 100+52+65+10=227100+52+65+10=227100+52+65+10=227 小图灵 100+36+65+10=211100+36+65+10=211100+36+65+10=211 好蒻啊，2=都悬 o(╥﹏╥)o $upd\\ on\\ 2021.11.01\\ $：€££公布分数 100+52+65+30=247100+52+65+30=247100+52+65+30=247，竟然比估分都高（窃喜）！看来我还是低估民间数据了。话说为甚么申诉都要收费啊！！！€££硼化硫！！！ ","link":"https://xinttao.github.io/post/CSP-J2021-tripnote-tao/"},{"title":"codeforces1267B Balls of Buma Solution","content":"可能更差的食用体验（？） 题目传送门 作为翻译人来水一篇题解。 鄙人不才，参考了@gyh20大佬的思路，并加以优化与说明。 样例解释{\\color{RoyalBlue} {样例解释}}样例解释 这个样例可以在第 333 到第 999 任意一个字符后插入一个“O”，共 9−3+1=79-3+1=79−3+1=7 种方式。 以在第 555 位插入一个“O”为例：第一次中间连续一段的“O”的长度因插入而变长且长度大于等于 333 ，满足消除条件。当中间的“O”被消除后，前后两段连续的“B”连成一段（即长度因“O”的消除而变长）且长度大于等于 333 ，再次消除。此时所有字符都被消除，即为一种成功的方案。读者可以尝试模拟在其他位置插入其他字符时游戏的过程。 主要思路{\\color{RoyalBlue} {主要思路}}主要思路 从上面的模拟不难看出，前面的字符必定只能与后面对应的字符连成一段并消除，例如：形如“AABBAAA”、“ABBCCBAA”等的字符串都是合法的，而形如“AABBAABB”、“AABBCCAABB”等的字符串都是不合法的。可以通过比较前后字符的方法从外向内进行消除。不难想到可以维护一个双向队列。 以第一个样例“BBWWBB”为例： deque&lt;char&gt;st B B W W B B 第一次，队列将两头的“B”弹出，并统计出个数为 444。个数大于等于 333，程序继续进行消除操作。 此时队列为： W W 第二次，队列将两头的“W”弹出，并统计出个数为 222。此时队列为空，个数只要大于等于 222 就为合法。此时可以在这一串“W”之间和前、后任意位置插入一个“W”，故答案为 2+1=32+1=32+1=3。 这一段消除的过程可以用以下代码实现： 还有一点要注意：如果队列的队首和队尾字符不相同或者队列的长度只有 111，都是不合法的字符串。只需在每次操作前判断一下即可。 总的时间复杂度为 O( st.size() )O(\\ st.size()\\ )O( st.size() )，非常优秀。 完整代码{\\color{RoyalBlue} {完整代码}}完整代码 ","link":"https://xinttao.github.io/post/codeforces1267B-Balls-of-Buma-Solution/"},{"title":"luoguP7308 Preokret Solution","content":"posted on 2021-09-29 17:50:38 | under 题解 | 题目传送门 Analysis{\\color{SkyBlue}Analysis}Analysis 我们需要得到两个问题的答案： 上半场总共得了多少分？（整场比赛持续 4×124 \\times 124×12 分钟。） 发生多少次反超？（一次反超定义为一支队伍在得分小于对方后，经过投球使得得分超过对方。） Ideas{\\color{SkyBlue}Ideas}Ideas （1）我们首先来解决第一个问题： 由于整场比赛持续 4×124 \\times 124×12 分钟，所以上半场比赛共有 2∗12∗60=1440(s)2*12*60=1440(s)2∗12∗60=1440(s) 。那么只要 ti&lt;=1440t_i&lt;=1440ti​&lt;=1440 ，就要增加 ansansans 。 （2）我们接着解决第二个问题： 我们可以先计算每一个时刻的分数。如果有队伍在之前的分数是小于对方，现在的分数是大于对方，那么这就是反超！（其实真的很简单！！） 但是，我们需要注意这种情况： A队分数 B队分数 3 4 4 4 4 5 这是不算反超的！！（因为B队一直都是领先A队的。） Code{\\color{SkyBlue}Code}Code 说明：By Xin。本人乃2016级小学生，思路比较简单，题解如有写的不好的地方请指正。 ","link":"https://xinttao.github.io/post/luogup7308-preokret-solution/"}]}